use std::env;

pub mod builder
{
    use std::fs::File;
    use std::io::Read;
    use std::io::Write;

    #[derive(Debug)]
    pub struct Page
    {
        pub head: String,
        pub body: String,
    }

    impl Page
    {
        pub fn new() -> Self
        {
            Page {
                head: "".to_string(),
                body: "".to_string(),
            }
        }

        pub fn add_style(self: &mut Self, style: &str)
        {
            self.head += &format!("<link rel=\"stylesheet\" href=\"{}\">", style);
        }

        pub fn generate(self: &mut Self) -> String
        {
            let mut result: String = format!("");
            result += "<!DOCTYPE html>";
            result += "<html>";
            result += "<head>";
            result += &self.head;
            result += "</head>";
            result += "<body>";
            result += &self.body;
            result += "</body>";
            result += "</html>";
            result += "<!-- Generated by delwg-rust -->";
            return result;
        }

        pub fn save(self: &mut Self, path: &str)
        {
            let mut file = File::create(path).unwrap();
            writeln!(&mut file, "{}", &self.generate()).unwrap();
        }
    }

    pub fn file_to_string(source: &str) -> String
    {
        let mut file = File::open(source).unwrap();
        let mut contents = String::new();
        file.read_to_string(&mut contents).unwrap();
        return contents;
    }
}

pub mod markdown
{
    use std::fs::File;
    use std::io::Read;
    pub fn parse_file(source: &str) -> String
    {
        let mut file = File::open(source).unwrap();
        let mut contents = String::new();
        file.read_to_string(&mut contents).unwrap();
        parse(&contents)
    }

    pub fn parse(source: &str) -> String
    {
        let mut result: String = String::new();
        let mut tmp: String = String::from(source);

        if source.len() < 1
        {
            return result;
        }

        tmp = tmp.replace("\\n", "</br>");
        // divider
        tmp = tmp.replace("\\---", "<hr>");
        // image with style
        tmp = regex::Regex::new(r"!\[(.+?)\]\((.+?)\)\{(.+?)\}")
            .unwrap()
            .replace_all(&tmp, "<img src=\"$2\" alt=\"$1\" style=\"$3\">")
            .to_string();
        // images
        tmp = regex::Regex::new(r"!\[(.+?)\]\((.+?)\)")
            .unwrap()
            .replace_all(&tmp, "<img src=\"$2\" alt=\"$1\">")
            .to_string();
        // links
        tmp = regex::Regex::new(r"\[(.+?)\]\((.+?)\)")
            .unwrap()
            .replace_all(&tmp, "<a href=\"$2\">$1</a>")
            .to_string();
        // bold
        tmp = regex::Regex::new(r"\*\*(.+?)\*\*")
            .unwrap()
            .replace_all(&tmp, "<b>$1</b>")
            .to_string();

        let mut in_paragraph: bool = false;

        for line in tmp.split("\n")
        {
            // TODO: We never open and close p on same line, so might as well make them exclusive
            let mut result_line: String = line.to_string();

            if line.starts_with("<<TAG>>")
            {
                continue;
            }

            // if not in paragragh then make one
            if !in_paragraph
            {
                result.push_str("<p>");
                in_paragraph = true;
            }

            // parse empty line cases
            if line == ""
            {
                // end the paragraph
                if in_paragraph
                {
                    result.push_str("</p>");
                    in_paragraph = false;
                }
                else
                {
                    result.push_str("</br>");
                }
                continue;
            }

            // 1st char
            let first_char = line.chars().nth(0).unwrap();
            // handle titles
            if first_char == '#'
            {
                let header_count = {
                    let mut count = 0;
                    for chars in line.chars()
                    {
                        if chars == '#'
                        {
                            count += 1;
                        }
                        else
                        {
                            break;
                        }
                    }
                    count
                };
                result_line = format!(
                    "<h{}>{}</h{}>",
                    header_count,
                    &line[header_count..],
                    header_count
                );
            }

            result.push_str(&result_line);
        }

        // close paragraph if still open
        if in_paragraph
        {
            result.push_str("</p>");
        }

        // way to shorten html without modifying parsing logic
        result = result.replace("<p></p>", "</br>");

        return result;
    }
}

use chrono;
use std::fs;

fn main()
{
    // set working directory
    let work_dir = "/home/del/projects/rust/delwgrust/";
    _ = env::set_current_dir(work_dir);

    // templates directory
    let templates_dir = "delwg-del.cx/";

    // generated site directory
    let web_dir = "web/";

    // generating header
    let head = builder::file_to_string(&(templates_dir.to_owned() + "template/head.html"))
        .replace("{TITLE}", "Mihails M");

    // generating site menus
    let mut menu = builder::file_to_string(&(templates_dir.to_owned() + "template/menu.html"));
    let mut menu_blog = menu.clone();
    menu = menu.replace("{PATH}", "");
    menu_blog = menu_blog.replace("{PATH}", "../");

    // generate footer
    let mut footer = builder::file_to_string(&(templates_dir.to_owned() + "template/footer.html"));
    let date = chrono::offset::Local::now()
        .format("%Y-%m-%d %H:%M:%S")
        .to_string();
    let year = chrono::offset::Local::now().format("%Y").to_string();
    footer = footer.replace("{GENERATED_DATE}", &date);
    footer = footer.replace("{CURRENT_YEAR}", &year);

    /****** GENERATING PAGES ******/
    // index.html
    let mut index = builder::Page::new();
    index.head = head.clone();
    index.add_style("style.css");
    index.add_style("textStyle.css");
    let links = builder::file_to_string(&(templates_dir.to_owned() + "template/links.html"));
    let cv = markdown::parse_file(&(templates_dir.to_owned() + "cv.md"));
    index.body += &menu;
    index.body += &links;
    index.body += &cv;
    index.body += &footer;
    index.save(&(work_dir.to_owned() + web_dir + "index.html"));

    // find all blog pages and build them
    let mut blog_links: Vec<String> = vec![];
    for file in fs::read_dir(&(templates_dir.to_owned() + "blog")).unwrap()
    {
        let file_name = file.unwrap().path().display().to_string();
        if file_name.ends_with(".md")
        {
            let page_file = file_name.replace(".md", ".html");
            let mut blog_page = builder::Page::new();
            let blog_markdown = builder::file_to_string(&(work_dir.to_owned() + &file_name));

            blog_page.add_style("../style.css");
            blog_page.add_style("../textStyle.css");
            let blog_content = markdown::parse(&blog_markdown);
            blog_page.body += &menu_blog;
            blog_page.body += &blog_content;
            blog_page.body += &footer;
            blog_page.save(
                &(work_dir.to_owned() + &web_dir + "blog/" + &page_file.split("/").last().unwrap()),
            );

            // add link of this blog page to blog page host
            let tag = "<<TAG>>";
            let marker_start = blog_markdown.find(tag).unwrap() + tag.len();
            let marker_end = blog_markdown[marker_start..].find(tag).unwrap() + tag.len();
            let tag_raw = &blog_markdown[marker_start..marker_end];

            let date = tag_raw.split('|').last().unwrap();
            let title = tag_raw.split('|').nth(0).unwrap();

            let link = format!(
                "[{}] <a href=\"blog/{}\">{}</a></br>",
                date,
                &page_file.split("/").last().unwrap(),
                title
            );
            blog_links.push(link);
        }
    }

    // blog.html
    blog_links.sort();
    blog_links.reverse();
    let links_string = blog_links.join("");

    let mut blog = builder::Page::new();
    blog.head = head.clone();
    blog.add_style("style.css");
    blog.add_style("textStyle.css");
    blog.body += &menu;
    blog.body += &links_string;
    blog.body += &footer;
    blog.save(&(work_dir.to_owned() + web_dir + "blog.html"));

    // TODO: generate blog page with the menu
}


// Unit tests
include!("test_markdown.rs");
